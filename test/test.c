int int huy;
/*

	int main = 0;
name
\\\\\////
**//*/



&@#$#@$EfFsfd

*/

// typedef'ы
typedef volatile struct huy 
{
	int a;
	short po;
}const * const dd, ll, ****zhopa;

int sum(void)
{

}


typedef  union{
	struct huy zhopa  raz;
	zhopa dva;
	int tri;
} testdef, *ptestdef;

dd h = 190;
ll pipka, oikq;
zhopa oooo;

//* массивки */
int a[][1][2][3][4];
int *a[4][9];
struct sss
{
	char test;
	int *field[4][9];
} arr[99] = 0;

char * test_string = "Compiles - parasha";

int ***a;

const int * a;
int ** const a;

int  const * const a;
int * const a;
const int extern static * volatile a;
const int *a;
int const *a;

//ругается, как и надо
//int const*;

extern volatile struct a
{
	int a;
  /*тип поля*/
} 
b = {10, {/*когда структура вложена в структуру*/102987, "dawdad"}};

/* тест битовых полей */
struct adasdsadsad
{
	int adsad;
	
	int bitfield : 10;
	int bitf : 1, bb1, :2, bb2 : 2;
	auto poopol;
	struct j
	{
		int aa;
	};
  /*тип поля*/
};

int const char * const  peremennaya;

long long short int _var = 199;
static unsigned long long int extern  a;


// просто какая-то параша \
с инициализацией
char *a, d, u, g = 1232;


///* так тоже можно */
volatile int;


enum my_enum1
{
	hello = 2,
	bonjour
} privet;


// запятая в конце - норма
enum my_enum2
{
	buy = 0,
	au_revoir = 10,
} poka;


struct test_struct
{
	int u, oo;
	struct j
	{
		int aa;
	} a;
	struct k
	{
		int bb;
	};
} test = {10};

volatile union test_union
{

	long double dubl;
	enum my_enum a;
	struct j
	{
		int aa;
	} a;
};
int unsigned long ger;
unsigned long long x = a*b;
//int char x;
long* main (
register int argc, 
int static argv)
{
	int a = b+123/4124;
	auto poopol;
	int x = sum("efjwnef", d);
	if (a > b)
		return a;
	else
	{
		hello(" hello", b);
		b = a++;
		return b;
	}
	char void * p = (void char *)malloc(sizeof(int short)*height * 2 + 1);
	do
		{
			i++;
		} while (1);
		int x = a*b;
		
	int **rows = (const int **)malloc(sizeof(int)*height * 2 + 1);

}

// тестирование свичей
void switch_test()
{
	int swtest = 10;
	
	goto house; // метку можно более одного раза указать, даже можно ее поставить в свич
	
	switch(swtest)
	{
house:	// корректно 
		default:
		int i = 0;
house:	// корректно
		break;
		
		
		case 43:
		continue;/// должен агриться (можно использовать только внутри циклов)
		break;
		
		default:/// должен агриться: более одного дефолта низя
		break;
	}
	
	default: // можно использовать только в свиче
		i+=109;

	switch(98) // свич может быть пустым
	{
	
	}

	house:	// корректно
	printf("Hopa-na");
	
	//case:
	//i++;
	
	case 187: // должен агриться
	i--;
}


